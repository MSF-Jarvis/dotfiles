#!/bin/bash

# Bash colors
CL_GRN='\033[01;32m'
CL_BOLD="\033[1m"
CL_INV="\033[7m"
CL_RED="\033[01;31m"
CL_RST="\033[0m"
CL_YLW="\033[01;33m"
CL_BLUE="\033[01;34m"


# Resources
THREAD="-j$(nproc --all)"
DEFCONFIG="caesium_defconfig"
KERNEL="Image.gz-dtb"
TREES="rr:oreo|aosip:oreo-mr1|xos:XOS-8.1"

# Caesium Kernel Details
KERNEL_NAME="Caesium"
INCREMENTAL_VERSION="AtheistApricot"
LOCALVERSION=-${INCREMENTAL_VERSION}
GIT_HASH=$(git rev-parse --short HEAD)
DEVICE="oneplus3"
FINAL_VER="${KERNEL_NAME}-${DEVICE}-${INCREMENTAL_VERSION}"

# Vars
ARCH=arm64
SUBARCH=arm64
KBUILD_BUILD_USER=MSF
KBUILD_BUILD_HOST=jarvisbox

# Paths
WORKING_DIR=$(pwd)
ANYKERNEL_DIR="${WORKING_DIR}/../AnyKernel2"
TOOLCHAIN_DIR="${WORKING_DIR}/../toolchains/aarch64-linux-gnu/"
REPACK_DIR="${ANYKERNEL_DIR}"
OUT_DIR="${WORKING_DIR}/out/"
ZIP_MOVE="${WORKING_DIR}/zips/"
MAKE="make O=${OUT_DIR} ARCH=${ARCH} SUBARCH=${SUBARCH}"

## Functions

# Prints a formatted header to let the user know what's being done
function echoText {
    echo -e ${CL_RED}
    echo -e ${CL_BOLD}
    echo -e "====$( for i in $( seq ${#1} ); do echo -e "=\c"; done )===="
    echo -e "==  ${1}  =="
    echo -e "====$( for i in $( seq ${#1} ); do echo -e "=\c"; done )===="
    echo -e ${CL_RST}
}

# Prints an error in bold red
function reportError {
    echo -e ""
    echo -e ${CL_RED}"${1}"${CL_RST}
    if [[ -z ${2} ]]; then
        echo -e ""
    fi
    exit 1
}

# Prints a warning in bold yellow
function reportWarning {
    echo -e ""
    echo -e ${CL_YLW}"${1}"${CL_RST}
    if [[ -z ${2} ]]; then
        echo -e ""
    fi
}

# Prints the success banner
function reportSuccess {
    echo -e ${CL_GRN}
    echo -e ${CL_BOLD}
    echo -e "====$( for i in $( seq ${#1} ); do echo -e "=\c"; done )===="
    echo -e "==  ${1}  =="
    echo -e "====$( for i in $( seq ${#1} ); do echo -e "=\c"; done )===="
    echo -e ${CL_RST}
}

# Send a markdown encoded Telegram message
function tgm {
    chat_id="${2}"
    [[ "${2}" == "" ]] && chat_id="${MSF_TG_ID}"
    curl -F chat_id="${chat_id}" -F parse_mode="markdown" -F text="${1}" "https://api.telegram.org/bot${TG_BOT_ID}/sendMessage" 1>/dev/null 2>/dev/null
}

# Pushes a local file to my webserver
function publish {
    rsync -avR ${1} root@download.msfjarvis.website:/var/www/${2}/ --progress --verbose
}

# The meat of the telegram notifications workflow
function pushcaesiumtg {
    local FILE=${1}
    local TYPE=${2}
    local FINAL_VER=$(echo ${FILE} | sed 's/\.zip//')
    case ${TYPE} in
        "alpha"|"beta"|"stable"|"test") ;;
        *) echo "Invalid build type" && return ;;
    esac
    local CHANGELOG_FILE=${FINAL_VER}_changelog.txt
    local LAST_TAG=$(git tag --sort=-taggerdate -l | head -n1)
    local RANGE=${LAST_TAG}..HEAD
    echo "${FINAL_VER}" > zips/${CHANGELOG_FILE}
    git log ${RANGE} | git shortlog ${RANGE} >> zips/${CHANGELOG_FILE}
    git diff --find-renames --stat --summary ${RANGE} >> zips/${CHANGELOG_FILE}
    cd zips;md5sum ${FILE} > ${FILE}.md5
    for item in ${FILE} ${CHANGELOG_FILE} ${FILE}.md5; do
        publish ${item} caesium/${TYPE}
    done
    cd ../
    if [ ${TYPE} == "stable" ]; then
      release ${FILE}
    fi
    if [ ${TYPE} != "test" ]; then
      tgm "New [${TYPE}](${JARVISBOX_URL}/${TYPE}) build uploaded : [${FILE}](${JARVISBOX_URL}/${TYPE}/${FILE})" "${OP3_CAESIUM_CHAT_ID}"
    fi
    tgm "New [${TYPE}](${JARVISBOX_URL}/${TYPE}) build uploaded : [${FILE}](${JARVISBOX_URL}/${TYPE}/${FILE})" "${OP3_JAGRAV_CHAT_ID}"
}

# Called by pushcaesiumtg on release builds
function release {
    local FILE=${1}
    local TAG=$(echo ${FILE} | cut -d / -f 2 | cut -d '-' -f 3 | sed 's/\.zip//')
    git -C ../AnyKernel2/ push origin HEAD:8.1.x-caesium
    git -C ../AnyKernel2/ tag ${TAG}
    git -C ../AnyKernel2/ push origin ${TAG}
    git push origin HEAD:XOS-8.1
    git tag -a ${TAG}
    git push origin ${TAG}
    git branch --set-upstream-to=origin/XOS-8.1
    hub release create ${TAG} -a zips/${FILE} -a zips/${CHANGELOG_FILE} -a zips/${FILE}.md5
    git branch --set-upstream-to=staging/XOS-8.1
    update_source_trees ${TAG}
}

# Takes a predefined list of trees to merge into and
# programmatically updates them to the latest tag.
function update_source_trees {
    local TAG=${1}
    IFS='|' read -r -a MERGEABLES <<< "${TREES}"
    for ITEM in "${MERGEABLES[@]}"; do
        IFS=':' read -r -a ELEMENTS <<< "${ITEM}"
        if [ ${#ELEMENTS[@]} -ge 2 ]; then
            REMOTE=${ELEMENTS[0]}
            BRANCH=${ELEMENTS[1]}
            git fetch ${REMOTE} ${BRANCH} --no-tags
            git checkout ${BRANCH}
            git merge ${TAG}
            git push ${REMOTE} ${BRANCH}
        fi
    done
}

# Find the correct CROSS_COMPILE candidate
function check_toolchain() {
    export TC="$(find ${TOOLCHAIN_DIR}/bin -type f -name *-gcc)";
        if [[ -f "${TC}" ]]; then
                export CROSS_COMPILE="$(command -v ccache) ${TOOLCHAIN_DIR}/bin/$(echo ${TC} | awk -F '/' '{print $NF'} | sed -e 's/gcc//')";
                echoText "$Using toolchain: $(${CROSS_COMPILE}gcc --version | head -1)"
        else
                reportError "No suitable toolchain found in ${TOOLCHAIN_DIR}";
        fi
}

# Duh
function make_kernel {
  make_defconfig
  if [ ${MODULE} ]; then
      if [ ${VERBOSE} ]; then
          ${MAKE} ${MODULE} ${THREAD}
      else
          ${MAKE} ${MODULE} ${THREAD} |& ag "error:|warning"
      fi
  else
      if [ ${VERBOSE} ]; then
          ${MAKE} ${KERNEL} ${THREAD}
      else
          ${MAKE} ${KERNEL} ${THREAD} |& ag "error:|warning"
      fi
  fi
  local BUILT_KERNEL=out/arch/${ARCH}/boot/${KERNEL}
  [ -f "${BUILT_KERNEL}" ] && cp -r ${BUILT_KERNEL} ${REPACK_DIR} && return 0 || reportError "Kernel compilation failed"
}

# Called by make_kernel, used to trap defconfig regen events
function make_defconfig {
  [ ${CLEAN} ] && rm -rf ${OUT_DIR}
  ${MAKE} ${DEFCONFIG} ${THREAD} 1>/dev/null 2>/dev/null
  ${MAKE} savedefconfig ${THREAD} 1>/dev/null 2>/dev/null
  [ ${REGEN_DEFCONFIG} ] && cp ${OUT_DIR}/defconfig arch/${ARCH}/configs/${DEFCONFIG} && echoText "Regenerated defconfig successfully" && exit 1
}

# Create the final ZIP
function make_zip {
  cd ${REPACK_DIR}
  echo ${FINAL_VER} > version
  rm *.zip 2>/dev/null
  [[ ${TEST_BUILD} ]] && FINAL_VER=${FINAL_VER}-$(date +"%Y%m%d"-"%H%M%S")
  zip -r ${FINAL_VER}.zip * -x ".git/*" "README.md" ".gitignore" "*.zip" 1>/dev/null 2>/dev/null
  mkdir -p ${ZIP_MOVE}
  cp  ${FINAL_VER}.zip ${ZIP_MOVE}/
  cd ${WORKING_DIR}
}

while getopts ":cbrm:t:" opt; do
  case $opt in
    c)
      echoText " Building clean " >&2
      CLEAN=true
      ;;
    b)
      echoText " Building ZIP only " >&2
      ONLY_ZIP=true
      ;;
    r)
      echoText " Regenerating defconfig " >&2
      REGEN_DEFCONFIG=true
      ;;
    t)
      TYPE=${OPTARG}
      if [[ ${TYPE} != "stable" ]]; then
          echoText " Setting test build parameters" >&2
          TEST_BUILD=true
          export LOCALVERSION="-${INCREMENTAL_VERSION}-${GIT_HASH}"
      fi
      ;;
    m)
      MODULE=${OPTARG}
      [[ ${MODULE} == */ ]] || MODULE=${MODULE}/
      if [[ ! "$(ls ${MODULE}Kconfig*  2>/dev/null)" ]]; then
          reportError "Invalid module specified - ${MODULE}"
          return 1
      fi
      echoText "Building module ${MODULE}"
      ;;
    \?)
      reportWarning "Invalid option: -${OPTARG}" >&2
      ;;
  esac
done

DATE_START=$(date +"%s")

# Make
check_toolchain
if [ ${ONLY_ZIP} ]; then
  make_zip
else
  make_kernel
  make_zip
fi

DATE_END=$(date +"%s")
DIFF=$((${DATE_END} - ${DATE_START}))
if [[ -f zips/${FINAL_VER}.zip ]]; then
    reportSuccess ${FINAL_VER}.zip
    if [[ ${TEST_BUILD} ]]; then
        pushcaesiumtg ${FINAL_VER}.zip ${TYPE}
    fi
fi

reportWarning "Time: $(($DIFF / 60)) minute(s) and $(($DIFF % 60)) seconds."
