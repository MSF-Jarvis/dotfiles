#!/usr/bin/env bash

# SPDX-License-Identifier: GPL-3.0-only #

# Source common functions
SCRIPT_DIR="$(cd "$( dirname $( readlink -f "${BASH_SOURCE[0]}" ) )" && pwd)"
BIN_FOLDER=${SCRIPT_DIR}/bin
source ${SCRIPT_DIR}/common

# Resources
DEFCONFIG="caesium_defconfig"
KERNEL="Image.gz-dtb"
TREES="rr:oreo|aosip:oreo-mr1"
JARVISBOX_URL="https://download.msfjarvis.website/caesium"

# Caesium Kernel Details
KERNEL_NAME="Caesium"
INCREMENTAL_VERSION="${CAESIUM_VERSION:?}"
LOCALVERSION="-${INCREMENTAL_VERSION}"
GIT_HASH=$(git rev-parse --short HEAD)
DEVICE="oneplus3"
FINAL_VER="${KERNEL_NAME}-${DEVICE}-${INCREMENTAL_VERSION}"

# Vars
ARCH=arm64
SUBARCH=arm64
USER=MSF
HOST=jarvisbox

# Paths
WORKING_DIR=$(pwd)
ANYKERNEL_DIR="${WORKING_DIR}/../AnyKernel2"
if [[ -z ${TOOLCHAIN_DIR} ]]; then
    TOOLCHAIN_DIR="${WORKING_DIR}/../toolchains/aarch64--glibc--bleeding-edge-2018.02-1/"
    TOOLCHAIN_SEARCH_STRING="*gnu-gcc"
fi
OUT_DIR="${WORKING_DIR}/out/"
ZIP_MOVE="${WORKING_DIR}/zips/"

## Functions

# Wrapper function around make to ensure all the variables go through
function make_wrapper {
    if [[ ! ${VERBOSE} ]]; then
        make O=${OUT_DIR} \
            ARCH=${ARCH} SUBARCH=${SUBARCH} \
            KBUILD_BUILD_USER=${USER} \
            KBUILD_BUILD_HOST=${HOST} \
            LOCALVERSION=${LOCALVERSION} \
            -j$(nproc --all) $@ |& ag "error:|warning"
    else
        make O=${OUT_DIR} \
            ARCH=${ARCH} SUBARCH=${SUBARCH} \
            KBUILD_BUILD_USER=${USER} \
            KBUILD_BUILD_HOST=${HOST} \
            LOCALVERSION=${LOCALVERSION} \
            -j$(nproc --all) $@
    fi
}

# Pushes a local file to my webserver
function publish {
    rsync -avR ${1} caddy@download.msfjarvis.website:/home/caddy/potatobox/caesium/${2}/ --progress --verbose
}

# Preps the server folder structure for new builds
function prepdirs {
    ssh caddy@download.msfjarvis.website mkdir -p /home/caddy/potatobox/caesium/${1}/
    ssh caddy@download.msfjarvis.website mkdir -p /home/caddy/potatobox/archive/${1}/
    ssh caddy@download.msfjarvis.website rm -rf /home/caddy/potatobox/archive/${1}/*
    ssh caddy@download.msfjarvis.website mv /home/caddy/potatobox/caesium/${1}/* /home/caddy/potatobox/archive/${1}/
}

# The meat of the telegram notifications workflow
function pushcaesiumtg {
    local FILE=${1}
    local TYPE=${2}
    local FINAL_VER=$(echo ${FILE} | sed 's/\.zip//')
    case ${TYPE} in
        "alpha"|"beta"|"stable"|"test") ;;
        *) echo "Invalid build type" && return ;;
    esac
    local CHANGELOG_FILE=${FINAL_VER}_changelog.txt
    local LAST_TAG=$(git describe --tags --abbrev=0)
    local RANGE=${LAST_TAG}..HEAD
    echo "${FINAL_VER}" > zips/${CHANGELOG_FILE}
    git log ${RANGE} | git shortlog ${RANGE} >> zips/${CHANGELOG_FILE}
    git diff --find-renames --stat --summary ${RANGE} >> zips/${CHANGELOG_FILE}
    cd zips;md5sum ${FILE} > ${FILE}.md5
    prepdirs ${TYPE}
    for item in ${FILE} ${CHANGELOG_FILE} ${FILE}.md5; do
        publish ${item} ${TYPE}
    done
    cd ../
    if [ ${TYPE} == "stable" ]; then
      release ${FILE}
    fi
    if [ ${TYPE} != "test" ]; then
      tgm "New [${TYPE}](${JARVISBOX_URL}/${TYPE}) build uploaded : [${FILE}](${JARVISBOX_URL}/${TYPE}/${FILE})" "${OP3_CAESIUM_CHAT_ID}"
    fi
    tgm "New [${TYPE}](${JARVISBOX_URL}/${TYPE}) build uploaded : [${FILE}](${JARVISBOX_URL}/${TYPE}/${FILE})" "${OP3_JAGRAV_CHAT_ID}"
}

# Called by pushcaesiumtg on release builds
function release {
    local FILE=${1}
    local TAG=$(echo ${FILE} | cut -d / -f 2 | cut -d '-' -f 3 | sed 's/\.zip//')
    git -C ../AnyKernel2/ push origin HEAD:8.1.x-caesium
    git -C ../AnyKernel2/ tag -s ${TAG}
    git -C ../AnyKernel2/ push origin ${TAG}
    git push origin HEAD:XOS-8.1
    git tag -as ${TAG}
    git push origin ${TAG}
    git branch --set-upstream-to=origin/XOS-8.1
    hub release create ${TAG} -a zips/${FILE} -a zips/${CHANGELOG_FILE} -a zips/${FILE}.md5
    git branch --set-upstream-to=staging/XOS-8.1
    update_source_trees ${TAG}
}

# Takes a predefined list of trees to merge into and
# programmatically updates them to the latest tag.
function update_source_trees {
    local TAG=${1}
    IFS='|' read -r -a MERGEABLES <<< "${TREES}"
    for ITEM in "${MERGEABLES[@]}"; do
        IFS=':' read -r -a ELEMENTS <<< "${ITEM}"
        if [ ${#ELEMENTS[@]} -ge 2 ]; then
            REMOTE=${ELEMENTS[0]}
            BRANCH=${ELEMENTS[1]}
            git fetch ${REMOTE} ${BRANCH} --no-tags
            git checkout ${BRANCH}
            git merge ${TAG}
            git push ${REMOTE} ${BRANCH}
        fi
    done
    git checkout XOS-8.1
}

# Find the correct CROSS_COMPILE candidate
function check_toolchain() {
    local TC="$(find ${TOOLCHAIN_DIR}/bin -name ${TOOLCHAIN_SEARCH_STRING})";
        if [[ -f "${TC}" ]]; then
                export CROSS_COMPILE="$(command -v ccache) ${TOOLCHAIN_DIR}/bin/$(echo ${TC} | awk -F '/' '{print $NF'} | sed -e 's/gcc//')";
                echoText "$Using toolchain: $(${CROSS_COMPILE}gcc --version | head -1)"
        else
                reportError "No suitable toolchain found in ${TOOLCHAIN_DIR}";
        fi
}

# Duh
function make_kernel {
  make_defconfig
  if [ ${MODULE} ]; then
      make_wrapper ${MODULE}
  else
      make_wrapper ${KERNEL}
  fi
  local BUILT_KERNEL=out/arch/${ARCH}/boot/${KERNEL}
  [ -f "${BUILT_KERNEL}" ] && cp -r ${BUILT_KERNEL} ${ANYKERNEL_DIR} && return 0 || reportError "Kernel compilation failed"
}

# Called by make_kernel, used to trap defconfig regen events
function make_defconfig {
  [ ${CLEAN} ] && rm -rf ${OUT_DIR}
  make_wrapper ${DEFCONFIG} 2>&1 >/dev/null
  make_wrapper savedefconfig 2>&1 >/dev/null
  [ ${REGEN_DEFCONFIG} ] && cp ${OUT_DIR}/defconfig arch/${ARCH}/configs/${DEFCONFIG} && echoText "Regenerated defconfig successfully" && exit 1
}

# Create the final ZIP
function make_zip {
  [[ ${TEST_BUILD} ]] && FINAL_VER=${FINAL_VER}-$(date +"%Y%m%d"-"%H%M%S")
  local UNSIGNED_ZIP=${FINAL_VER}_unsigned.zip
  local SIGNED_ZIP=${FINAL_VER}.zip
  cd ${ANYKERNEL_DIR}
  echo ${FINAL_VER} > version
  rm *.zip 2>/dev/null
  zip -r ${UNSIGNED_ZIP} * -x ".git/*" "README.md" ".gitignore" "*.zip" 2>&1 >/dev/null
  java -jar "${BIN_FOLDER}/zipsigner-2.1.jar" \
            "${UNSIGNED_ZIP}" \
            "${SIGNED_ZIP}"
  mkdir -p ${ZIP_MOVE}
  mv  ${SIGNED_ZIP} ${ZIP_MOVE}/
  cd ${WORKING_DIR}
}

while getopts ":cbrm:t:d:" opt; do
  case $opt in
    c)
      echoText " Building clean " >&2
      CLEAN=true
      ;;
    b)
      echoText " Building ZIP only " >&2
      ONLY_ZIP=true
      ;;
    r)
      echoText " Regenerating defconfig " >&2
      REGEN_DEFCONFIG=true
      ;;
    t)
      TYPE=${OPTARG}
      NOTIFY=true
      if [[ ${TYPE} != "stable" ]]; then
          echoText " Setting test build parameters" >&2
          TEST_BUILD=true
          export LOCALVERSION="-${INCREMENTAL_VERSION}-${GIT_HASH}"
      fi
      ;;
    m)
      MODULE=${OPTARG}
      [[ ${MODULE} == */ ]] || MODULE=${MODULE}/
      if [[ ! "$(ls ${MODULE}Kconfig*  2>/dev/null)" ]]; then
          reportError "Invalid module specified - ${MODULE}"
          return 1
      fi
      echoText "Building module ${MODULE}"
      ;;
     d)
      [[ ${OPTARG} != "garlic" ]] && return
      DEVICE=garlic
      ANYKERNEL_DIR="${WORKING_DIR}/../AnyKernel2_garlic"
      FINAL_VER="${KERNEL_NAME}-${DEVICE}-${INCREMENTAL_VERSION}"
      ;;
    \?)
      reportWarning "Invalid option: -${OPTARG}" >&2
      ;;
  esac
done

DATE_START=$(date +"%s")

# Make
check_toolchain
if [ ${ONLY_ZIP} ]; then
  make_zip
else
  make_kernel
  make_zip
fi

DATE_END=$(date +"%s")
DIFF=$((${DATE_END} - ${DATE_START}))
if [[ -f zips/${FINAL_VER}.zip ]]; then
    reportSuccess ${FINAL_VER}.zip
    if [[ ${DEVICE} != "garlic" ]]; then
        pushcaesiumtg ${FINAL_VER}.zip ${TYPE}
    fi
fi

reportWarning "Time: $(($DIFF / 60)) minute(s) and $(($DIFF % 60)) seconds."
